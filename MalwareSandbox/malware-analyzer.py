
"""
Malware Analyzer (Static Sandbox) - Profissional
- Hashes (MD5, SHA1, SHA256)
- Metadados (tamanho, tipo, timestamps)
- Strings (ASCII e UTF-16LE)
- Extração de URLs, domínios e IPs
- Heurísticas de risco + Entropia
- Detecção de PE (EXE/DLL) + seções via pefile (opcional)
- Integração opcional com VirusTotal (env var: VIRUSTOTAL_API_KEY)
- Relatório HTML (Bootstrap) + JSON
- CLI simples: arquivo(s), pasta de saída, flags

USO:
  python malware_analyzer.py --file caminho/arquivo.exe --out reports/
  python malware_analyzer.py --dir pasta_amostras --out reports/ --no-vt
"""

import argparse
import hashlib
import json
import logging
import os
import re
import sys
from datetime import datetime
from pathlib import Path

import mimetypes  # fallback para detecção simples de tipo

# Dependências leves e puramente Python
try:
    from colorama import Fore, Style, init as colorama_init
    colorama_init()
    COLOR = True
except Exception:
    COLOR = False

try:
    import requests
except Exception as e:
    print("Falta o 'requests'. Instale com: pip install requests")
    sys.exit(1)

try:
    from jinja2 import Environment, FileSystemLoader
except Exception:
    print("Falta o 'Jinja2'. Instale com: pip install Jinja2")
    sys.exit(1)

# Opcional: análise de PE (Windows executáveis) sem binários nativos
try:
    import pefile
    HAVE_PEFILE = True
except Exception:
    HAVE_PEFILE = False

LOG = logging.getLogger("malware-analyzer")
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s: %(message)s")

VT_API_ENV = "VIRUSTOTAL_API_KEY"


# ----------------- utilidades -----------------

def cprint(msg, level="info"):
    if not COLOR:
        getattr(LOG, level)(msg)
        return
    palette = {
        "info": Fore.CYAN + msg + Style.RESET_ALL,
        "warn": Fore.YELLOW + msg + Style.RESET_ALL,
        "error": Fore.RED + msg + Style.RESET_ALL,
        "ok": Fore.GREEN + msg + Style.RESET_ALL,
    }
    print(palette.get(level, msg))


def read_file_bytes(path: Path, max_size_mb=100):
    """Lê bytes do arquivo (limite de segurança)."""
    size_mb = path.stat().st_size / (1024 * 1024)
    if size_mb > max_size_mb:
        raise ValueError(f"Arquivo muito grande ({size_mb:.1f} MB). Ajuste o limite se necessário.")
    with open(path, "rb") as f:
        return f.read()


def calc_hashes(data: bytes):
    return {
        "md5": hashlib.md5(data).hexdigest(),
        "sha1": hashlib.sha1(data).hexdigest(),
        "sha256": hashlib.sha256(data).hexdigest(),
    }


def guess_filetype(path: Path, data: bytes):
    # Heurística rápida
    mime, _ = mimetypes.guess_type(str(path))
    kind = "desconhecido"
    if data[:2] == b"MZ":
        kind = "pe"   # Windows PE (EXE/DLL)
        mime = mime or "application/vnd.microsoft.portable-executable"
    elif data[:4] == b"%PDF":
        kind = "pdf"
        mime = mime or "application/pdf"
    elif data[:4] in (b"\x89PNG",):
        kind = "png"
        mime = mime or "image/png"
    elif data[:3] in (b"GIF",):
        kind = "gif"
        mime = mime or "image/gif"
    elif data[:2] in (b"BM",):  # BMP
        kind = "bmp"
        mime = mime or "image/bmp"
    elif data[:3] in (b"PK\x03", b"PK\x05", b"PK\x07"):  # zip jar docx xlsx
        kind = "zip-like"
        mime = mime or "application/zip"
    elif data[:4] in (b"\x7FELF",):
        kind = "elf"
        mime = mime or "application/x-elf"

    return {"kind": kind, "mime": mime or "desconhecido"}


def shannon_entropy(bs: bytes, window=None):
    from math import log2
    if not bs:
        return 0.0
    if window and len(bs) > window:
        # amostra parcial para evitar custo alto
        bs = bs[:window]
    counts = [0]*256
    for b in bs:
        counts[b] += 1
    probs = [c/len(bs) for c in counts if c]
    return -sum(p * log2(p) for p in probs)


def extract_strings(data: bytes, min_len=4):
    # ASCII
    ascii_strings = re.findall(rb"[ -~]{%d,}" % min_len, data)
    # UTF-16LE
    try:
        u16 = data.decode("utf-16le", errors="ignore")
        u16_strings = re.findall(r"[ -~]{%d,}" % min_len, u16)
    except Exception:
        u16_strings = []
    # normalizar
    ascii_str = [s.decode("latin-1", errors="ignore") for s in ascii_strings]
    return list(set(ascii_str + u16_strings))


URL_RE = re.compile(r"\bhttps?://[a-zA-Z0-9\-._~:/?#\[\]@!$&'()*+,;=%]+", re.IGNORECASE)
IP_RE = re.compile(r"\b(?:\d{1,3}\.){3}\d{1,3}\b")
DOMAIN_RE = re.compile(r"\b([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}\b")


def extract_iocs(strings_list):
    urls = set()
    ips = set()
    domains = set()
    for s in strings_list:
        urls.update(URL_RE.findall(s))
        ips.update(IP_RE.findall(s))
        domains.update(DOMAIN_RE.findall(s))
    # Limpar IPs improváveis (>255)
    valid_ips = set()
    for ip in ips:
        parts = ip.split(".")
        if all(p.isdigit() and 0 <= int(p) <= 255 for p in parts):
            valid_ips.add(ip)
    # Domínios — remover coisas óbvias não-domínio
    domains = {d for d in domains if len(d) >= 4 and "." in d}
    return {
        "urls": sorted(urls),
        "ips": sorted(valid_ips),
        "domains": sorted(domains),
    }


def vt_lookup(sha256: str, api_key: str):
    """Consulta simples ao VirusTotal (v3) por hash. Retorna dict enxuto."""
    headers = {"x-apikey": api_key}
    url = f"https://www.virustotal.com/api/v3/files/{sha256}"
    try:
        r = requests.get(url, headers=headers, timeout=25)
        if r.status_code == 404:
            return {"found": False, "message": "Hash não encontrado no VT."}
        r.raise_for_status()
        data = r.json()
        stats = data.get("data", {}).get("attributes", {}).get("last_analysis_stats", {})
        malicious = stats.get("malicious", 0)
        suspicious = stats.get("suspicious", 0)
        undetected = stats.get("undetected", 0)
        harmless = stats.get("harmless", 0)
        return {
            "found": True,
            "malicious": malicious,
            "suspicious": suspicious,
            "undetected": undetected,
            "harmless": harmless,
            "permalink": f"https://www.virustotal.com/gui/file/{sha256}"
        }
    except Exception as e:
        return {"found": False, "error": str(e)}


def pe_details(path: Path, data: bytes):
    """Detalhes sobre PE (se pefile disponível)."""
    if not HAVE_PEFILE or not data.startswith(b"MZ"):
        return None
    try:
        pe = pefile.PE(data=data, fast_load=True)
        pe.parse_data_directories()
        sects = []
        for s in pe.sections:
            sects.append({
                "name": s.Name.decode(errors="ignore").strip("\x00"),
                "virtual_size": s.Misc_VirtualSize,
                "raw_size": s.SizeOfRawData,
                "entropy": round(s.get_entropy(), 3),
                "characteristics": hex(s.Characteristics)
            })
        imports = []
        if hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll = entry.dll.decode(errors="ignore")
                funcs = [imp.name.decode(errors="ignore") if imp.name else f"ord_{imp.ordinal}"
                         for imp in entry.imports]
                imports.append({"dll": dll, "functions": funcs[:50]})  # limitar
        return {"sections": sects, "imports": imports[:30]}
    except Exception:
        return None


def risk_score(summary):
    """
    Calcula um score simples (0-100) baseado em heurísticas:
    - Alta entropia -> +15
    - Muitos IOCs -> +10
    - É PE e tem muitas seções com entropia alta -> +15
    - VirusTotal malicious/suspicious -> +10 / +5
    - Strings suspeitas (palavras-chave) -> +10
    """
    score = 0
    if summary.get("entropy", 0) >= 7.0:
        score += 15

    iocs = summary.get("iocs", {})
    if len(iocs.get("urls", [])) + len(iocs.get("ips", [])) + len(iocs.get("domains", [])) > 10:
        score += 10

    pe = summary.get("pe")
    if pe and pe.get("sections"):
        high = [s for s in pe["sections"] if s.get("entropy", 0) >= 7.0]
        if len(high) >= 2:
            score += 15

    vt = summary.get("virustotal")
    if vt and vt.get("found"):
        score += min(30, vt.get("malicious", 0) * 2 + vt.get("suspicious", 0))

    # Palavras-chave simples (ofuscação/exec remota).
    suspicious_keywords = ("powershell", "cmd.exe", "wscript", "javascript", "eval(", "base64", "shellcode")
    concat_strings = " ".join(summary.get("strings_preview", []))
    if any(k.lower() in concat_strings.lower() for k in suspicious_keywords):
        score += 10

    return min(100, score)


def severity_from_score(score):
    if score >= 75:
        return "ALTA"
    if score >= 40:
        return "MÉDIA"
    return "BAIXA"


def analyze_file(path: Path, vt_api_key: str = None, strings_limit=200):
    data = read_file_bytes(path)
    hashes = calc_hashes(data)
    ftype = guess_filetype(path, data)
    entropy = round(shannon_entropy(data, window=4_000_000), 3)
    strings = extract_strings(data, min_len=4)
    iocs = extract_iocs(strings)

    vt_res = None
    if vt_api_key:
        vt_res = vt_lookup(hashes["sha256"], vt_api_key)

    pe_info = None
    if ftype["kind"] == "pe":
        pe_info = pe_details(path, data)

    preview = strings[:strings_limit]
    summary = {
        "filename": path.name,
        "size": path.stat().st_size,
        "modified": datetime.fromtimestamp(path.stat().st_mtime).isoformat(timespec="seconds"),
        "hashes": hashes,
        "type": ftype,
        "entropy": entropy,
        "iocs": iocs,
        "strings_preview": preview,
        "pe": pe_info,
        "virustotal": vt_res or {"found": False}
    }
    summary["risk_score"] = risk_score(summary)
    summary["severity"] = severity_from_score(summary["risk_score"])
    return summary


def render_report(reports, output_html: Path):
    # garantir template
    tpl_dir = Path(__file__).parent / "templates"
    tpl_file = tpl_dir / "report_template.j2"
    if not tpl_file.exists():
        tpl_dir.mkdir(parents=True, exist_ok=True)
        # template mínimo fallback
        tpl_file.write_text("""<!doctype html><html><body><h1>Relatório</h1>
        {% for r in reports %}<h2>{{ r.filename }}</h2><pre>{{ r|tojson(indent=2) }}</pre>{% endfor %}
        </body></html>""", encoding="utf-8")

    env = Environment(loader=FileSystemLoader(str(tpl_dir)))
    env.filters["tojson"] = lambda v, indent=2: json.dumps(v, ensure_ascii=False, indent=indent)
    tpl = env.get_template("report_template.j2")
    html = tpl.render(
        generated_at=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        reports=reports
    )
    output_html.write_text(html, encoding="utf-8")


def main():
    parser = argparse.ArgumentParser(description="Malware Analyzer (Static Sandbox)")
    parser.add_argument("--file", help="Arquivo único para analisar")
    parser.add_argument("--dir", help="Pasta com amostras (analisa todos os arquivos)")
    parser.add_argument("--out", default="reports", help="Pasta de saída (HTML/JSON)")
    parser.add_argument("--no-vt", action="store_true", help="Desabilita consulta ao VirusTotal")
    parser.add_argument("--strings-limit", type=int, default=200, help="Limite de strings no preview")
    args = parser.parse_args()

    if not args.file and not args.dir:
        cprint("Informe --file ou --dir", "error")
        parser.print_help()
        sys.exit(1)

    vt_key = None if args.no_vt else os.getenv(VT_API_ENV)

    if not args.no_vt and not vt_key:
        cprint(f"Aviso: variável {VT_API_ENV} não definida. Rodando sem VirusTotal.", "warn")

    out_dir = Path(args.out)
    out_dir.mkdir(parents=True, exist_ok=True)

    # coletar arquivos
    targets = []
    if args.file:
        p = Path(args.file)
        if p.is_file():
            targets.append(p)
        else:
            cprint(f"Arquivo não encontrado: {p}", "error")
            sys.exit(1)
    if args.dir:
        d = Path(args.dir)
        if not d.is_dir():
            cprint(f"Pasta inválida: {d}", "error")
            sys.exit(1)
        for f in d.iterdir():
            if f.is_file():
                targets.append(f)

    if not targets:
        cprint("Nenhum arquivo para analisar.", "warn")
        sys.exit(0)

    cprint(f"Iniciando análise de {len(targets)} arquivo(s)...", "info")

    reports = []
    for i, path in enumerate(targets, 1):
        cprint(f"[{i}/{len(targets)}] Analisando: {path.name}", "info")
        try:
            rep = analyze_file(path, vt_api_key=vt_key, strings_limit=args.strings_limit)
            reports.append(rep)
        except Exception as e:
            cprint(f"Falha ao analisar {path.name}: {e}", "error")

    # salvar JSON consolidado
    json_out = out_dir / f"report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    json_out.write_text(json.dumps(reports, ensure_ascii=False, indent=2), encoding="utf-8")
    cprint(f"JSON salvo em: {json_out}", "ok")

    # gerar HTML
    html_out = out_dir / f"report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
    render_report(reports, html_out)
    cprint(f"HTML salvo em: {html_out}", "ok")

    cprint("Concluído.", "ok")


if __name__ == "__main__":
    main()